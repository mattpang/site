<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <link rel="icon" href="favicon.ico">
  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils@0.1/control_utils.css" crossorigin="anonymous">
<style>@keyframes spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}.abs{position:absolute}
body{bottom:0;font-family:"Titillium Web",sans-serif;left:0;margin:0;position:absolute;right:0;top:0;transform-origin:0px 0px;overflow:hidden}
.container{position:absolute;background-color:#596e73;height:720px;width:1280px}
.input_video{position:relative;top:0;left:0;right:0;bottom:0}
.input_video.selfie{transform:scale(-1, 1)}.output_canvas{position:absolute;height:720px;width:1280px;left:0;top:0}.logo{bottom:10px;right:20px}
.logo .title{color:#fff;font-size:28px}.logo .subtitle{position:relative;color:#fff;font-size:10px;left:-30px;top:20px}
.control-panel{position:absolute;left:10px;top:10px}
.loading{display:flex;position:absolute;top:0;right:0;bottom:0;left:0;align-items:center;backface-visibility:hidden;justify-content:center;opacity:1;transition:opacity 1s}
.loading .message{font-size:x-large}.loading 
.spinner{position:absolute;width:120px;height:120px;animation:spin 1s linear infinite;border:32px solid #bebebe;border-top:32px solid #3498db;border-radius:50%}
.loaded .loading{opacity:0}.shoutout{left:0;right:0;bottom:40px;text-align:center;font-size:24px;position:absolute}
</style>

<title>Semaphore</title>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.1/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils@0.1/control_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.2/drawing_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.2/pose.js" crossorigin="anonymous"></script>
</head>

<body>

<div style='margin: auto;width: 1280px;'>
<p>QWERTY keyboards too fast? Want a workout every time you write an email? Why not try flag semaphores? With the power of <a href="https://urldefense.proofpoint.com/v2/url?u=https-3A__ai.googleblog.com_2020_08_on-2Ddevice-2Dreal-2Dtime-2Dbody-2Dpose-2Dtracking.html&amp;d=DwMGAg&amp;c=eIGjsITfXP_y-DLLX0uEHXJvU8nOHrUK8IrwNKOtkVU&amp;r=SO8RcBjwLvmhIMNe510_X9DwYB72jaa0m4aoWQXx_DM&amp;m=JHjbG28Z-zEf7-rATzpMuMU649HoWHE4djwO6t2-KCA&amp;s=w88PBDei4MTVjVofNWu355YtzHDe24Tnf2TdI3hYHEY&amp;e=">deep learning</a>, you too can enjoy communiating the eighteenth century way.</p>
<p>Instructions: Open this page with Chrome/Firefox on a computer (soz mobiles and Safari) and allow the camera access. No data is sent anywhere, all this is done locally in your browser. 
Put yourself in the camera frame, then simply hold the <a href="https://urldefense.proofpoint.com/v2/url?u=https-3A__en.wikipedia.org_wiki_Flag-5Fsemaphore-23Characters&amp;d=DwMGAg&amp;c=eIGjsITfXP_y-DLLX0uEHXJvU8nOHrUK8IrwNKOtkVU&amp;r=SO8RcBjwLvmhIMNe510_X9DwYB72jaa0m4aoWQXx_DM&amp;m=JHjbG28Z-zEf7-rATzpMuMU649HoWHE4djwO6t2-KCA&amp;s=A1-FSS9arNNOaduOBMCj8WxaZ7HqCzLsVWuc5wMvQKc&amp;e=">desired signal position</a> for a few seconds, and each character shall appear in turn. The Rest signal will make a space, and the Cancel signal will delete the last character.</p>
<h2 id='results'  style='color:black;width:100%;text-align: center'> loading... </h2>
<h2 id='messagebox'  style='color:black;width:100%;text-align: center'> Text will appear here. </h2>

</div>

  <div class="container" style='left:15%;'>
    <video class="input_video"></video>
    <canvas class="output_canvas" width="1280px" height="720px"></canvas>
    <div class="loading">
      <div class="spinner"></div>
      <div class="message">
        Loading
      </div>
    </div>

    </div>
 

</div>


</body>
</html>

<script type="module">


      const flaglookup = {"270,225": {"letter": "A", "l": 270, "r": 225, "mode": "1"}, "270,180": {"letter": "B", "l": 270, "r": 180, "mode": "2"}, "270,135": {"letter": "C", "l": 270, "r": 135, "mode": "3"}, "270,90": {"letter": "D", "l": 270, "r": 90, "mode": "4"}, "45,270": {"letter": "E", "l": 45, "r": 270, "mode": "5"}, "0,270": {"letter": "F", "l": 0, "r": 270, "mode": "6"}, "315,270": {"letter": "G", "l": 315, "r": 270, "mode": "7"}, "225,180": {"letter": "H", "l": 225, "r": 180, "mode": "8"}, "225,135": {"letter": "I", "l": 225, "r": 135, "mode": "9"}, "0,90": {"letter": "J", "l": 0, "r": 90, "mode": "Letter"}, "90,225": {"letter": "K", "l": 90, "r": 225, "mode": "0"}, "45,225": {"letter": "L", "l": 45, "r": 225, "mode": NaN}, "0,225": {"letter": "M", "l": 0, "r": 225, "mode": NaN}, "315,225": {"letter": "N", "l": 315, "r": 225, "mode": NaN}, "135,180": {"letter": "O", "l": 135, "r": 180, "mode": NaN}, "90,180": {"letter": "P", "l": 90, "r": 180, "mode": NaN}, "45,180": {"letter": "Q", "l": 45, "r": 180, "mode": NaN}, "0,180": {"letter": "R", "l": 0, "r": 180, "mode": NaN}, "315,180": {"letter": "S", "l": 315, "r": 180, "mode": NaN}, "90,135": {"letter": "T", "l": 90, "r": 135, "mode": NaN}, "45,135": {"letter": "U", "l": 45, "r": 135, "mode": NaN}, "315,90": {"letter": "V", "l": 315, "r": 90, "mode": NaN}, "0,45": {"letter": "W", "l": 0, "r": 45, "mode": NaN}, "315,45": {"letter": "X", "l": 315, "r": 45, "mode": NaN}, "0,135": {"letter": "Y", "l": 0, "r": 135, "mode": NaN}, "0,315": {"letter": "Z", "l": 0, "r": 315, "mode": NaN}, "270,270": {"letter": " ", "l": 270, "r": 270, "mode": NaN}, "45,90": {"letter": "#", "l": 45, "r": 90, "mode": "Number"}, "315,135": {"letter": "-", "l": 315, "r": 135, "mode": "Backspace"}}

// store my predictions in here.
var charbuffer = '';
var message = [];


// Our input frames will come from here.
const videoElement = document.getElementsByClassName('input_video')[0];
const canvasElement = document.getElementsByClassName('output_canvas')[0];
const controlsElement = document.getElementsByClassName('control-panel')[0];
const canvasCtx = canvasElement.getContext('2d');

// We'll add this to our control panel later, but we'll save it here so we can
// call tick() each time the graph runs.
///const fpsControl = new FPS();

// Optimization: Turn off animated spinner after its hiding animation is done.
const spinner = document.querySelector('.loading');
spinner.ontransitionend = () => {
  spinner.style.display = 'none';
};

function zColor(data) {
  const z = clamp(data.from.z + 0.5, 0, 1);
  return `rgba(0, ${255 * z}, ${255 * (1 - z)}, 1)`;
}

Math.degrees = function(radians) {
	return radians * 180 / Math.PI;
}

function calcangle(shoulder,wrist){
  const xs = shoulder['x']
  const ys = shoulder['y']  

  const xw = wrist['x']
  const yw = wrist['y']

  const dx = xs-xw
  const dy = ys-yw
  // convert to degs
  const x = Math.atan2(dy,dx)

  
  return (x > 0 ? x : (2*3.14 + x)) * 360 / (2*3.14)
}

function snap45(angle){
  return Math.round(angle/45)*45
}


var getMax = function (str) {
 var max = 0,
     maxChar = '';
  str.split('').forEach(function(char){
    if(str.split(char).length > max) {
        max = str.split(char).length;
        maxChar = char;
     }
  });
  return maxChar;
};

function onResults(results) {
  // Hide the spinner.
  document.body.classList.add('loaded');

  // Update the frame rate.
  //fpsControl.tick();
  
    // right shoulder to hands: 11,13,15
    //left should to hands: 12,14,16

    const rangle = calcangle(results.poseLandmarks[12], results.poseLandmarks[16])
    const langle = calcangle(results.poseLandmarks[11], results.poseLandmarks[15])


    try {
      const seenletter = flaglookup[String(snap45(rangle)+','+snap45(langle))]['letter']
      document.getElementById('results').innerHTML  =  'Letter: '+seenletter
      charbuffer+=seenletter
      if (charbuffer.length > 50){
        var thismaxchar = getMax(charbuffer)
        console.log(thismaxchar);
        if (thismaxchar=='s') 
        {message += ' ';}
        else if (thismaxchar=='-') 
        {message = message.slice(0, -1)}
        else
        {message += thismaxchar;}

        charbuffer = '' ;
        document.getElementById('messagebox').innerHTML  = message;

      }
      //flaglookup[String(snap45(langle)+','+snap45(rangle))]['letter'];
    }
    catch(err) {
      document.getElementById('results').innerHTML  = 'No letter found.';
    }


  // Draw the overlays.
  canvasCtx.save();
  canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
  canvasCtx.drawImage(
      results.image, 0, 0, canvasElement.width, canvasElement.height);
  drawConnectors(
      canvasCtx, results.poseLandmarks, POSE_CONNECTIONS, {
        color: (data) => {
          const x0 = canvasElement.width * data.from.x;
          const y0 = canvasElement.height * data.from.y;
          const x1 = canvasElement.width * data.to.x;
          const y1 = canvasElement.height * data.to.y;

          const z0 = clamp(data.from.z + 0.5, 0, 1);
          const z1 = clamp(data.to.z + 0.5, 0, 1);

          const gradient = canvasCtx.createLinearGradient(x0, y0, x1, y1);
          gradient.addColorStop(
              0, `rgba(0, ${255 * z0}, ${255 * (1 - z0)}, 1)`);
          gradient.addColorStop(
              1.0, `rgba(0, ${255 * z1}, ${255 * (1 - z1)}, 1)`);
          return gradient;
        }
      });
  drawLandmarks(
      canvasCtx,
      Object.values(POSE_LANDMARKS_LEFT)
          .map(index => results.poseLandmarks[index]),
      {color: zColor, fillColor: '#FF0000'});
  drawLandmarks(
      canvasCtx,
      Object.values(POSE_LANDMARKS_RIGHT)
          .map(index => results.poseLandmarks[index]),
      {color: zColor, fillColor: '#00FF00'});
  drawLandmarks(
      canvasCtx,
      Object.values(POSE_LANDMARKS_NEUTRAL)
          .map(index => results.poseLandmarks[index]),
      {color: zColor, fillColor: '#AAAAAA'});
  canvasCtx.restore();
}

const pose = new Pose({locateFile: (file) => {
  return `https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.2/${file}`;
}});
pose.onResults(onResults);

/**
 * Instantiate a camera. We'll feed each frame we receive into the solution.
 */
const camera = new Camera(videoElement, {
  onFrame: async () => {
    await pose.send({image: videoElement});
  },
  width: 1280,
  height: 720
});
camera.start();

// Present a control panel through which the user can manipulate the solution
// options.
new ControlPanel(controlsElement, {
      selfieMode: true,
      upperBodyOnly: true,
      smoothLandmarks: true,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5
    })
    .on(options => {
      pose.setOptions(options);
    });

</script>


